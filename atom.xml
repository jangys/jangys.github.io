<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JANG&#39;s BLOG</title>
  
  <subtitle>For My Ability</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jangys.github.io/"/>
  <updated>2018-02-19T17:39:15.599Z</updated>
  <id>http://jangys.github.io/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[AlgoSpot] CLOCK SYNC - 모든 경우의 수를 살펴보기 / 재귀 호출</title>
    <link href="http://jangys.github.io/2018/02/20/CLOCK-SYNC/"/>
    <id>http://jangys.github.io/2018/02/20/CLOCK-SYNC/</id>
    <published>2018-02-19T16:21:13.000Z</published>
    <updated>2018-02-19T17:39:15.599Z</updated>
    
    <content type="html"><![CDATA[<p><center>문제는 <a href="https://algospot.com/judge/problem/read/CLOCKSYNC" rel="external nofollow noopener noreferrer" target="_blank">https://algospot.com/judge/problem/read/CLOCKSYNC</a> 이 곳에서 확인해 볼 수 있습니다.</center><br><br><br></p><h3 id="문제-ClockSync"><a href="#문제-ClockSync" class="headerlink" title="문제 ClockSync"></a>문제 ClockSync</h3><p><img src="https://user-images.githubusercontent.com/23052219/36390678-33d5f966-15e7-11e8-9461-7e1e559a6405.png" alt="문제"></p><p>위 그림과 같이 4 X 4 배열로 배치된 16개의 시계가 있다. 이 시계들으 3,6,9,12시를 가르킨다.</p><p><img src="https://user-images.githubusercontent.com/23052219/36390147-4aaab73c-15e5-11e8-833b-3bb6eb0376a5.png" alt="문제2"><br>시계를 조작하는 방법은 위의 스위치를 누르는 것이다. 표는 스위치 번호와 그 스위치와 연결된 시계 번호를 나타낸 것이다.<br>예를 들어 0번 스위치를 누르면 0,1,2번 시계가 눌리는 것이다.(시계는 맨 윗줄부터 왼쪽에서 오른쪽으로 번호를 매겼다.)<br>한 번 누를때 마다 <strong>3시간씩 앞으로</strong> 움직인다.<br>이때 <strong>모든</strong> 시계를 <strong>12시로</strong> 돌리기 위한 <strong>최소한 눌러야 할 스위치 수</strong> 를 계산하시오.</p><p><strong>입력</strong><br>첫 줄에는 테스트 케이스 개수 C(&lt;= 30)이 주어진다.<br>각 테스트 케이스는 한 줄에 16개의 정수가 주어지며 3,6,9,12중 하나의 값을 가진다.</p><p><strong>출력</strong><br>스위치를 눌러야할 최소 수를 출력하는데 불가능할 경우 -1을 출력한다.</p><p><strong>예제 입출력</strong><br>2<br>12 6 6 6 6 6 12 12 12 12 12 12 12 12 12 12<br>12 9 3 12 6 6 9 3 12 9 12 9 12 12 6 6</p><p>2<br>9</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;center&gt;문제는 &lt;a href=&quot;https://algospot.com/judge/problem/read/CLOCKSYNC&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[AlgoSpot] BOARD COVER - 모든 경우의 수를 살펴보기 / 재귀 호출</title>
    <link href="http://jangys.github.io/2018/02/13/BOARD-COVER/"/>
    <id>http://jangys.github.io/2018/02/13/BOARD-COVER/</id>
    <published>2018-02-12T16:24:38.000Z</published>
    <updated>2018-02-19T17:36:58.064Z</updated>
    
    <content type="html"><![CDATA[<p><center>문제는 <a href="https://algospot.com/judge/problem/read/BOARDCOVER" rel="external nofollow noopener noreferrer" target="_blank">https://algospot.com/judge/problem/read/BOARDCOVER</a> 이 곳에서 확인해 볼 수 있습니다.</center><br><br><br></p><h3 id="문제-BoardCover"><a href="#문제-BoardCover" class="headerlink" title="문제 BoardCover"></a>문제 BoardCover</h3><p><img src="https://user-images.githubusercontent.com/23052219/36108989-724789e8-1061-11e8-9843-dd1fcd779716.png" alt="문제"></p><p>H x W 크기의 게임판이 있을 때 게임판의 모든 흰 칸을 <strong>L자 모양의 블록</strong> 으로 덮고 싶다. 블록은 회전이 가능하며 겹치거나 검은 판을 덮거나 게임판 밖으로 나가는 것은 불가능하다. 이때 이를 <strong>덮는 방법의 수</strong> 를 계산하시오.</p><p>첫 줄에는 테스트 케이스의 수 C (C &lt;= 30) 가 주어진다. 각 테스트 케이스의 첫 줄에는 2개의 정수 H, W (1 &lt;= H,W &lt;= 20) 가 주어진다. 다음 H 줄에 각 W 글자로 게임판의 모양이 주어지는데 <strong># 은 검은 칸, . 는 흰 칸</strong> 을 나타낸다. 입력에 주어지는 게임판에 있는 흰 칸의 수는 50 을 넘지 않는다.</p><h3 id="풀이-모든-경우의-수를-살펴보기"><a href="#풀이-모든-경우의-수를-살펴보기" class="headerlink" title="풀이 - 모든 경우의 수를 살펴보기"></a>풀이 - 모든 경우의 수를 살펴보기</h3><p>흰 칸의 수가 적으므로 모든 경우의 수를 살펴 봐도 수행시간안에 문제를 풀 수 있습니다.<br>이를 효율적으로 하기 위해서는 <strong>재귀함수</strong> 가 필요합니다.</p><p>재귀함수를 구현할 때 생각해야 하는 것이 크게 두 가지가 있습니다.</p><ol><li>문제를 풀기 위해 어떤 일을 <strong>반복적이게</strong> 하는지 찾기 -&gt; 이를 이용해 재귀 함수의 기능을 구현</li><li><strong>기저 사례(base case)</strong> 찾기 -&gt; 재귀함수에서 return 조건이 어떻게 되는 가. 즉 최소 작업일때 바로 <strong>반환할 값</strong> 설정.<br>이때 입력 범위를 벗어나는 것도 기저 사례에 넣으면 오류를 줄일 수 있음.</li></ol><p>이를 토대로 재귀함수를 구현해봅시다.<br>저는 기저 사례로 <strong>현재 흰 칸에 있는 L자 블록 수 &gt;= L자 블록이 흰 칸에 놓아질 수 있는 수</strong> 로 정했습니다.<br>이외에도 칸의 끝까지 살펴보았을 때를 기저사례로 정해도 되지만 저는 저 기저 사례가 더 효율적이라 판단했습니다.<br>L자 블록이 흰 칸에 놓아질 수 있는 수를 구하는 것은 간단합니다. <strong>흰 블록 수 / 3</strong> 을 하면 됩니다.<br>L자 모양 블록은 무조건 3칸을 차지하기 떄문입니다.<br>이를 이용해 <em>흰 칸의 수가 3으로 나눠떨어지지 않는다면 경우의 수를 0</em> 으로 곧바로 반환하는 방법도 생각할 수 있습니다.</p><p>어떤 <em>반복적인 일</em> 을 해야 이 문제가 해결되는지 생각해봅시다.<br>저는 먼저 L자 블록이 회전해서 만들어질 수 있는 모양을 생각해보았습니다. 그 모양은 아래와 같습니다.<br><img src="https://user-images.githubusercontent.com/23052219/36110076-c3d3b8ce-1064-11e8-897c-d77c69d1bcb6.png" alt="L자블록"><br>총 4가지 모양인 것을 확인할 수 있습니다.<br>반복적인 일은 다음과 같습니다.</p><ul><li>왼쪽에서 오른쪽 방향으로 검사할 때 제일 처음으로 나오는 흰 칸 확인</li></ul><ol><li>4가지 모양이 그 흰 칸에 들어가는지 확인</li><li>들어간다면 L자 블록으로 덮기</li></ol><ul><li>다음 칸으로 이동. L자 블록 수 기록.</li></ul><p>1,2 가 반복적인 일이고 이를 이용해 문제를 풀기 위해서는 ●가 필요합니다.<br>이 때 다음 칸으로 이동할 때 재귀 호출을 이용합니다. L자 블록을 덮은 채 이동하므로 자동으로 다음 흰 칸에 대한 L자 블록을 찾을 수 있습니다.<br>여기서 <em>주의할 사항</em> 이 있습니다.<br>L자 블록으로 덮고 재귀 호출을 한 후 블록 수를 추가하고 L자 블록으로 덮었던 부분을 <strong>원상 복귀</strong> 시켜야합니다.<br>그래야 해당 흰 칸에서 들어갈 수 있는 다른 L자 블록에 대해서도 검사할 수 있습니다. 원상 복귀를 시키지 않는다면 겹치게 될테니깐요.</p><p>여기서 4가지 모양이 들어가는지 검사할 때 좀 더 효율적으로 할 수 있는 방법이 있습니다.<br><strong>배열</strong> 을 이용해 미리 4가지 모양을 입력한 후 이를 <strong>for문</strong> 과 같은 반복문을 이용해 검사하면 됩니다. (자세한 구현은 코드를 참고해주세요)<br>위의 4가지 모양 그림에서 검은색 부분을 기준으로 (x,y)를 (0,0)이라 하면 1번의 경우는 (0,0) , (0,1) , (1,1) 이 됩니다. 아래로 내려가면 +1, 오른쪽으로 가면 +1이 되는 방식입니다. 이 <em>보드판의 시작은 왼쪽 위에서 시작해서 오른쪽 아래 방향</em> 으로 가기 때문이죠.<br>이 모양이 검은 칸과 겹치지 않는지, 보드판을 벗어나지 않는지 등을 검사해서 들어갈 수 있는지의 여부를 판단하면 됩니다.</p><p>코드의 구현은 다음과 같습니다. <strong>JAVA</strong> 로 구현했습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> BOARDCOVER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoardCover</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][][] cover = &#123;&#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;&#125;,</span><br><span class="line">&#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;&#125;,</span><br><span class="line">&#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;,</span><br><span class="line">&#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">1</span>&#125;&#125;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> testCase;</span><br><span class="line"><span class="keyword">int</span> board[][];</span><br><span class="line"><span class="keyword">int</span> countingCase[];</span><br><span class="line"></span><br><span class="line">Scanner scn = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">testCase = scn.nextInt();</span><br><span class="line">countingCase = <span class="keyword">new</span> <span class="keyword">int</span>[testCase];</span><br><span class="line">scn.nextLine();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;testCase;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> col = scn.nextInt();</span><br><span class="line"><span class="keyword">int</span> row = scn.nextInt();</span><br><span class="line"><span class="keyword">int</span> whiteNum = <span class="number">0</span>;</span><br><span class="line">scn.nextLine();</span><br><span class="line">board = <span class="keyword">new</span> <span class="keyword">int</span>[col][row];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;col;y++) &#123;</span><br><span class="line">String temp = scn.nextLine();</span><br><span class="line"><span class="comment">// # == 1 , . == 0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;row;x++) &#123;</span><br><span class="line"><span class="keyword">if</span>(temp.charAt(x)==<span class="string">'#'</span>) &#123;</span><br><span class="line">board[y][x]=<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp.charAt(x) == <span class="string">'.'</span>) &#123;</span><br><span class="line">board[y][x]=<span class="number">0</span>;</span><br><span class="line">whiteNum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//input complete</span></span><br><span class="line"><span class="keyword">if</span>(whiteNum%<span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">countingCase[i] = countCase(board,whiteNum/<span class="number">3</span>,<span class="number">0</span>,col, row);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">countingCase[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;testCase;i++) &#123;</span><br><span class="line">System.out.println(countingCase[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countCase</span><span class="params">(<span class="keyword">int</span> board[][], <span class="keyword">int</span> canCover, <span class="keyword">int</span> current, <span class="keyword">int</span> col, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> isWhite = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span>(current &gt;= canCover) &#123; <span class="comment">// base case</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(y = <span class="number">0</span>; y&lt;col; y++) &#123;</span><br><span class="line"><span class="keyword">for</span>(x=<span class="number">0</span>; x&lt;row; x++) &#123;</span><br><span class="line"><span class="keyword">if</span>(board[y][x] == <span class="number">0</span>) &#123;</span><br><span class="line">isWhite = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isWhite) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//흰 칸인 곳을 찾기</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(set(board,y,x,i,col,row)) &#123;<span class="comment">//그 흰 칸을 기준으로 L자 블록이 들어간다면</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>;a&lt;<span class="number">3</span>;a++) &#123;<span class="comment">//L자 블록으로 덮음</span></span><br><span class="line">board[ y + cover[i][a][<span class="number">1</span>]][x + cover[i][a][<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">count += countCase(board,canCover,current+<span class="number">1</span>,col,row);<span class="comment">//다음 블록 놓을 곳을 찾기 위해 재귀호출</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>;a&lt;<span class="number">3</span>;a++) &#123;<span class="comment">//L자 블록으로 덮은 것을 다시 원상복귀 시키기</span></span><br><span class="line">board[ y + cover[i][a][<span class="number">1</span>]][x + cover[i][a][<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//L자 블록이 들어갈 수 있는지 검사</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> board[][], <span class="keyword">int</span> nY,<span class="keyword">int</span> nX, <span class="keyword">int</span> type,<span class="keyword">int</span> col, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line"><span class="keyword">int</span> y = nY + cover[type][i][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> x = nX + cover[type][i][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(y&lt;<span class="number">0</span> || x&lt; <span class="number">0</span> ||y &gt;= col || x &gt;= row || board[y][x] == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;center&gt;문제는 &lt;a href=&quot;https://algospot.com/judge/problem/read/BOARDCOVER&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;http
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Introduction - 소개글</title>
    <link href="http://jangys.github.io/2018/02/02/First-Post/"/>
    <id>http://jangys.github.io/2018/02/02/First-Post/</id>
    <published>2018-02-01T16:27:56.000Z</published>
    <updated>2018-02-12T16:16:04.516Z</updated>
    
    <content type="html"><![CDATA[<center>예비개발자입니다.</center><br><center>앞으로 제가 공부한 알고리즘과 제가 했던 프로젝트에 대해서 정리할 예정입니다.</center><center>깃허브 블로그는 처음이라 서툴지만 잘부탁드립니다.</center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;예비개발자입니다.&lt;/center&gt;&lt;br&gt;&lt;center&gt;앞으로 제가 공부한 알고리즘과 제가 했던 프로젝트에 대해서 정리할 예정입니다.&lt;/center&gt;

&lt;center&gt;깃허브 블로그는 처음이라 서툴지만 잘부탁드립니다.&lt;/center&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
